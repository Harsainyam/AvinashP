<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Transaction Integration Tests - Credora</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div class="test-container">
    <div class="test-header">
      <h1>ðŸ’¸ Transaction Integration Tests</h1>
      <p>Testing transfers, transaction history, and validation</p>
    </div>

    <div class="test-controls">
      <button id="run-tests">Run All Tests</button>
      <button id="clear-results">Clear Results</button>
      
      <div class="config-section">
        <label for="api-url">API URL:</label>
        <input type="text" id="api-url" value="http://localhost:5000/api">
      </div>
      
      <div class="config-section">
        <label for="test-token">Access Token:</label>
        <input type="text" id="test-token" placeholder="Paste token from auth test">
        <button id="load-token" style="padding: 0.5rem 1rem; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer;">
          Load Saved Token
        </button>
      </div>
    </div>

    <div id="test-results">
      <p class="loading">Click "Run All Tests" to begin</p>
    </div>
  </div>

  <script src="test-helpers.js"></script>
  <script>
    const runner = new TestRunner();
    let api;
    let testAccounts = [];
    let testTransaction = null;
    let destinationAccount = null;
    let initialBalance = null;

    // Setup - Get accounts and find destination
    async function setupAccounts() {
      const { data } = await api.get('/accounts?fresh=true');
      testAccounts = data.data;
      
      console.log('Test accounts loaded:', testAccounts);
      
      if (testAccounts.length === 0) {
        throw new Error('No accounts found. Please run authentication tests first.');
      }
      
      // For testing, we need a destination account
      // Try to find the seeded account, or use any available account
      const seedAccount = testAccounts.find(acc => acc.account_number === '1007654321');
      destinationAccount = seedAccount ? seedAccount.account_number : '1007654321';
      
      // Store initial balance for comparison
      initialBalance = parseFloat(testAccounts[0].balance);
      
      TestStorage.set('testAccounts', testAccounts);
      TestStorage.set('initialBalance', initialBalance);
    }

    // Test Suite 1: Transaction Validation
    runner.describe('Transaction Validation', (it) => {
      it('should setup test accounts', async () => {
        await setupAccounts();
        expect(testAccounts.length).toBeGreaterThan(0);
      });

      it('should reject transfer without source account', async () => {
        const { response, data } = await api.post('/transactions', {
          toAccountNumber: destinationAccount,
          amount: 50,
          description: 'Test transfer'
        });
        
        console.log('No source account:', { status: response.status, data });
        
        expect(response.status).toBe(400);
        expect(data.success).toBeFalsy();
      });

      it('should reject transfer without destination account', async () => {
        const { response, data } = await api.post('/transactions', {
          fromAccountId: testAccounts[0]?.id,
          amount: 50,
          description: 'Test transfer'
        });
        
        expect(response.status).toBe(400);
        expect(data.success).toBeFalsy();
      });

      it('should reject transfer without amount', async () => {
        const { response, data } = await api.post('/transactions', {
          fromAccountId: testAccounts[0]?.id,
          toAccountNumber: destinationAccount,
          description: 'Test transfer'
        });
        
        expect(response.status).toBe(400);
        expect(data.success).toBeFalsy();
      });

      it('should reject negative amount', async () => {
        const { response, data } = await api.post('/transactions', {
          fromAccountId: testAccounts[0]?.id,
          toAccountNumber: destinationAccount,
          amount: -50,
          description: 'Test transfer'
        });
        
        expect(response.status).toBe(400);
        expect(data.success).toBeFalsy();
      });

      it('should reject zero amount', async () => {
        const { response, data } = await api.post('/transactions', {
          fromAccountId: testAccounts[0]?.id,
          toAccountNumber: destinationAccount,
          amount: 0,
          description: 'Test transfer'
        });
        
        expect(response.status).toBe(400);
        expect(data.success).toBeFalsy();
      });

      it('should reject invalid account number', async () => {
        const { response, data } = await api.post('/transactions', {
          fromAccountId: testAccounts[0]?.id,
          toAccountNumber: '123',
          amount: 50,
          description: 'Test transfer'
        });
        
        expect(response.status).toBe(400);
        expect(data.success).toBeFalsy();
      });

      it('should validate amount precision', async () => {
        const { response, data } = await api.post('/transactions', {
          fromAccountId: testAccounts[0]?.id,
          toAccountNumber: destinationAccount,
          amount: 10.999, // Too many decimal places
          description: 'Test transfer'
        });
        
        // Should either accept (rounding) or reject with validation error
        if (!response.ok) {
          expect([400, 201]).toContain(response.status);
        }
      });
    });

    // Test Suite 2: Transaction Business Logic
    runner.describe('Transaction Business Logic', (it) => {
      it('should reject transfer to non-existent account', async () => {
        const { response, data } = await api.post('/transactions', {
          fromAccountId: testAccounts[0]?.id,
          toAccountNumber: '9999999999',
          amount: 10,
          description: 'Test transfer to invalid account'
        });
        
        console.log('Non-existent account:', { status: response.status, data });
        
        expect(response.status).toBe(400);
        expect(data.success).toBeFalsy();
      });

      it('should reject transfer to same account', async () => {
        const { response, data } = await api.post('/transactions', {
          fromAccountId: testAccounts[0]?.id,
          toAccountNumber: testAccounts[0]?.account_number,
          amount: 10,
          description: 'Test self-transfer'
        });
        
        console.log('Same account transfer:', { status: response.status, data });
        
        expect(response.status).toBe(400);
        expect(data.success).toBeFalsy();
      });

      it('should reject transfer with insufficient balance', async () => {
        const { response, data } = await api.post('/transactions', {
          fromAccountId: testAccounts[0]?.id,
          toAccountNumber: destinationAccount,
          amount: 999999999,
          description: 'Test insufficient balance'
        });
        
        console.log('Insufficient balance:', { status: response.status, data });
        
        expect(response.status).toBe(400);
        expect(data.success).toBeFalsy();
      });

      it('should successfully transfer valid amount', async () => {
        const transferAmount = 10;
        const { response, data } = await api.post('/transactions', {
          fromAccountId: testAccounts[0]?.id,
          toAccountNumber: destinationAccount,
          amount: transferAmount,
          description: 'Integration test transfer'
        });
        
        console.log('Successful transfer:', { status: response.status, data });
        
        if (response.status === 201) {
          testTransaction = data.data;
          expect(data.success).toBeTruthy();
          expect(testTransaction).toHaveProperty('referenceNumber');
          expect(testTransaction.amount).toBe(transferAmount);
          
          if (testTransaction.balanceAfter !== undefined) {
            const expectedBalance = initialBalance - transferAmount;
            expect(parseFloat(testTransaction.balanceAfter)).toBe(expectedBalance);
          }
          
          TestStorage.set('testTransaction', testTransaction);
        } else {
          console.warn('Transfer failed, status:', response.status);
          // Allow test to continue even if transfer fails
        }
      });

      it('should update sender balance after transfer', async () => {
        const storedTransaction = TestStorage.get('testTransaction');
        
        if (storedTransaction) {
          await wait(1000); // Wait for DB to update
          
          const { response, data } = await api.get(`/accounts/${testAccounts[0].id}/balance`);
          
          console.log('Updated balance:', data.data);
          
          const newBalance = parseFloat(data.data.balance);
          expect(typeof newBalance).toBe('number');
          expect(newBalance).toBeLessThan(initialBalance);
        } else {
          console.warn('No transaction to verify, skipping balance check');
        }
      });

      it('should support optional description field', async () => {
        const { response, data } = await api.post('/transactions', {
          fromAccountId: testAccounts[0]?.id,
          toAccountNumber: destinationAccount,
          amount: 5
          // No description field
        });
        
        // Should succeed even without description
        if (response.status === 201) {
          expect(data.success).toBeTruthy();
        }
      });
    });

    // Test Suite 3: Get Transaction History
    runner.describe('Transaction History', (it) => {
      it('should retrieve transaction history', async () => {
        const { response, data } = await api.get('/transactions');
        
        console.log('Transaction history:', { status: response.status, count: data.data?.length });
        
        expect(response.status).toBe(200);
        expect(data.success).toBeTruthy();
        expect(Array.isArray(data.data)).toBeTruthy();
      });

      it('should return transaction details', async () => {
        const { response, data } = await api.get('/transactions');
        
        if (data.data.length > 0) {
          const txn = data.data[0];
          expect(txn).toHaveProperty('id');
          expect(txn).toHaveProperty('transaction_type');
          expect(txn).toHaveProperty('amount');
          expect(txn).toHaveProperty('status');
          expect(txn).toHaveProperty('reference_number');
          expect(txn).toHaveProperty('created_at');
        }
      });

      it('should support pagination with limit', async () => {
        const { response, data } = await api.get('/transactions?limit=5');
        
        expect(response.status).toBe(200);
        expect(Array.isArray(data.data)).toBeTruthy();
        expect(data.data.length).toBeLessThan(6);
      });

      it('should support pagination with offset', async () => {
        const { response, data } = await api.get('/transactions?limit=5&offset=0');
        
        expect(response.status).toBe(200);
        expect(Array.isArray(data.data)).toBeTruthy();
      });

      it('should filter by transaction type', async () => {
        const { response, data } = await api.get('/transactions?type=transfer');
        
        if (data.data.length > 0) {
          data.data.forEach(txn => {
            expect(txn.transaction_type).toBe('transfer');
          });
        }
      });

      it('should filter by account', async () => {
        const accountId = testAccounts[0]?.id;
        const { response, data } = await api.get(`/transactions?accountId=${accountId}`);
        
        expect(response.status).toBe(200);
        expect(Array.isArray(data.data)).toBeTruthy();
      });

      it('should sort by date descending', async () => {
        const { response, data } = await api.get('/transactions?limit=10');
        
        if (data.data.length > 1) {
          const dates = data.data.map(txn => new Date(txn.created_at).getTime());
          
          for (let i = 1; i < dates.length; i++) {
            expect(dates[i-1]).toBeGreaterThan(dates[i]);
          }
        }
      });

      it('should handle empty transaction history', async () => {
        // Try with a very high offset
        const { response, data } = await api.get('/transactions?offset=99999');
        
        expect(response.status).toBe(200);
        expect(Array.isArray(data.data)).toBeTruthy();
      });
    });

    // Test Suite 4: Get Transaction Details
    runner.describe('Transaction Details', (it) => {
      let transactionId;

      it('should get specific transaction by ID', async () => {
        const { data: historyData } = await api.get('/transactions?limit=1');
        
        if (historyData.data.length > 0) {
          transactionId = historyData.data[0].id;
          const { response, data } = await api.get(`/transactions/${transactionId}`);
          
          console.log('Transaction details:', { status: response.status, data: data.data });
          
          expect(response.status).toBe(200);
          expect(data.success).toBeTruthy();
          expect(data.data.id).toBe(transactionId);
          
          TestStorage.set('transactionId', transactionId);
        } else {
          console.warn('No transactions found for detail test');
        }
      });

      it('should include account details', async () => {
        const storedId = TestStorage.get('transactionId') || transactionId;
        
        if (storedId) {
          const { response, data } = await api.get(`/transactions/${storedId}`);
          
          // Should have at least one account number
          const hasAccountInfo = data.data.from_account_number || data.data.to_account_number;
          expect(hasAccountInfo).toBeTruthy();
        }
      });

      it('should reject invalid transaction ID', async () => {
        const { response, data } = await api.get('/transactions/invalid-id');
        
        expect(response.status).toBe(400);
        expect(data.success).toBeFalsy();
      });

      it('should reject non-existent transaction', async () => {
        const fakeUUID = '00000000-0000-0000-0000-000000000000';
        const { response, data } = await api.get(`/transactions/${fakeUUID}`);
        
        expect(response.status).toBe(404);
        expect(data.success).toBeFalsy();
      });

      it('should only return user own transactions', async () => {
        const storedId = TestStorage.get('transactionId') || transactionId;
        
        if (storedId) {
          const { response, data } = await api.get(`/transactions/${storedId}`);
          
          // Should successfully retrieve own transaction
          expect(response.status).toBe(200);
        }
      });
    });

    // Test Suite 5: Transaction Status
    runner.describe('Transaction Status', (it) => {
      it('should have valid status values', async () => {
        const { response, data } = await api.get('/transactions');
        
        const validStatuses = ['pending', 'completed', 'failed', 'reversed'];
        
        data.data.forEach(txn => {
          expect(validStatuses).toContain(txn.status);
        });
      });

      it('should complete transfers immediately', async () => {
        const { response, data } = await api.get('/transactions?type=transfer&limit=5');
        
        if (data.data.length > 0) {
          const completedCount = data.data.filter(txn => txn.status === 'completed').length;
          expect(completedCount).toBeGreaterThan(0);
        }
      });

      it('should have valid transaction types', async () => {
        const { response, data } = await api.get('/transactions');
        
        const validTypes = ['transfer', 'deposit', 'withdrawal', 'payment'];
        
        data.data.forEach(txn => {
          expect(validTypes).toContain(txn.transaction_type);
        });
      });
    });

    // Test Suite 6: Transaction Security
    runner.describe('Transaction Security', (it) => {
      it('should require authentication', async () => {
        const noAuthAPI = new APIHelper(api.baseURL);
        const { response, data } = await noAuthAPI.post('/transactions', {
          fromAccountId: testAccounts[0]?.id,
          toAccountNumber: destinationAccount,
          amount: 10
        });
        
        expect(response.status).toBe(401);
        expect(data.success).toBeFalsy();
      });

      it('should only allow user own accounts', async () => {
        const fakeUUID = '00000000-0000-0000-0000-000000000000';
        const { response, data } = await api.post('/transactions', {
          fromAccountId: fakeUUID,
          toAccountNumber: destinationAccount,
          amount: 10
        });
        
        expect(response.status).toBeGreaterThan(0);
        expect(data.success).toBeFalsy();
      });

      it('should generate unique reference numbers', async () => {
        const { data } = await api.get('/transactions?limit=10');
        
        if (data.data.length > 0) {
          const references = data.data.map(txn => txn.reference_number);
          const uniqueRefs = new Set(references);
          
          expect(uniqueRefs.size).toBe(references.length);
        }
      });

      it('should have proper reference number format', async () => {
        const { data } = await api.get('/transactions?limit=5');
        
        data.data.forEach(txn => {
          expect(txn.reference_number).toMatch(/^TXN/);
          expect(txn.reference_number.length).toBeGreaterThan(5);
        });
      });

      it('should prevent concurrent transaction issues', async () => {
        // Try to make two simultaneous transactions
        const promises = [
          api.post('/transactions', {
            fromAccountId: testAccounts[0]?.id,
            toAccountNumber: destinationAccount,
            amount: 1,
            description: 'Concurrent test 1'
          }),
          api.post('/transactions', {
            fromAccountId: testAccounts[0]?.id,
            toAccountNumber: destinationAccount,
            amount: 1,
            description: 'Concurrent test 2'
          })
        ];
        
        const results = await Promise.all(promises);
        
        // Both should either succeed or one should fail due to balance
        results.forEach(result => {
          expect([201, 400]).toContain(result.response.status);
        });
      });
    });

    // Test Suite 7: Rate Limiting
    runner.describe('Rate Limiting', (it) => {
      it('should enforce transaction rate limits', async () => {
        console.log('Testing rate limits (this may take a moment)...');
        
        const requests = [];
        for (let i = 0; i < 12; i++) {
          requests.push(
            api.post('/transactions', {
              fromAccountId: testAccounts[0]?.id,
              toAccountNumber: destinationAccount,
              amount: 0.01,
              description: `Rate limit test ${i}`
            })
          );
        }
        
        const results = await Promise.all(requests);
        const rateLimited = results.filter(r => r.response.status === 429);
        
        // At least one should be rate limited (10 per minute limit)
        if (rateLimited.length > 0) {
          expect(rateLimited.length).toBeGreaterThan(0);
          console.log(`${rateLimited.length} requests were rate limited`);
        } else {
          console.warn('No rate limiting detected - may need adjustment');
        }
      });
    });

    // Load saved token button handler
    document.getElementById('load-token').addEventListener('click', () => {
      const savedToken = TestStorage.get('accessToken');
      if (savedToken) {
        document.getElementById('test-token').value = savedToken;
        alert('Token loaded from previous test session!');
      } else {
        alert('No saved token found. Please run authentication tests first.');
      }
    });

    // Event Listeners
    document.getElementById('run-tests').addEventListener('click', async () => {
      const apiUrl = document.getElementById('api-url').value;
      const token = document.getElementById('test-token').value;
      
      if (!token) {
        alert('Please provide an access token first! Run the Auth tests to get one or click "Load Saved Token".');
        return;
      }
      
      api = new APIHelper(apiUrl);
      api.setToken(token);
      
      document.getElementById('run-tests').disabled = true;
      document.getElementById('test-results').innerHTML = '<h2>Running Tests...</h2>';
      
      try {
        await runner.run();
      } catch (error) {
        console.error('Test runner error:', error);
        alert('Test run failed: ' + error.message);
      } finally {
        document.getElementById('run-tests').disabled = false;
      }
    });

    document.getElementById('clear-results').addEventListener('click', () => {
      document.getElementById('test-results').innerHTML = '<p class="loading">Click "Run All Tests" to begin</p>';
      runner.results = { passed: 0, failed: 0, total: 0 };
    });

    // Auto-load token on page load
    window.addEventListener('load', () => {
      const savedToken = TestStorage.get('accessToken');
      if (savedToken) {
        document.getElementById('test-token').value = savedToken;
        console.log('Auto-loaded saved token');
      }
    });
  </script>
</body>
</html>